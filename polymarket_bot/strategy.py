"""
Base strategy interface and implementations
"""
from abc import ABC, abstractmethod
from typing import List, Dict, Any, Optional
from dataclasses import dataclass
import logging
import time
import requests
import json
import os
from datetime import datetime
from dateutil import parser

logger = logging.getLogger(__name__)


@dataclass
class Signal:
    """Trading signal generated by a strategy"""

    token_id: str
    side: str  # "BUY" or "SELL"
    size: float  # Amount in USDC
    price: Optional[float] = None  # None for market orders
    reason: str = ""  # Why this signal was generated

    @property
    def is_market_order(self) -> bool:
        """Check if this is a market order"""
        return self.price is None


class BaseStrategy(ABC):
    """
    Abstract base class for trading strategies

    Subclass this to implement your own trading logic
    """

    def __init__(self, name: str):
        """
        Initialize strategy

        Args:
            name: Strategy name for logging
        """
        self.name = name
        self.logger = logging.getLogger(f"strategy.{name}")

    @abstractmethod
    def generate_signals(
        self,
        markets: List[Dict[str, Any]],
        positions: List[Dict[str, Any]],
        balance: float,
    ) -> List[Signal]:
        """
        Generate trading signals based on market data and current positions

        Args:
            markets: List of available markets
            positions: Current positions
            balance: Available USDC balance

        Returns:
            List of trading signals
        """
        pass

    def on_order_filled(self, order: Dict[str, Any]) -> None:
        """
        Callback when an order is filled

        Args:
            order: Order data
        """
        pass

    def on_order_rejected(self, order: Dict[str, Any], reason: str) -> None:
        """
        Callback when an order is rejected

        Args:
            order: Order data
            reason: Rejection reason
        """
        pass


class CopyTradingStrategy(BaseStrategy):
    """
    自动跟单策略 v2.0

    功能：
    - 追踪目标用户的交易活动
    - 自动复制买入/卖出信号
    - 支持固定金额跟单或按比例跟单
    - 持久化已处理交易，避免重复跟单
    - 完善的市场信息缓存
    - API 重试机制
    """

    # 目标用户地址（可配置）
    DEFAULT_TARGET_USER = "0x96489abcb9f583d6835c8ef95ffc923d05a86825"

    def __init__(
        self,
        target_user: str = None,
        copy_amount: float = 10.0,           # 固定跟单金额（USDC）
        copy_ratio: float = None,             # 跟单比例（覆盖 copy_amount）
        time_window: int = 300,               # 只跟 N 秒内的新单（默认 5 分钟）
        enable_partial_copy: bool = True,     # 是否允许部分复制（大单拆分）
        max_copy_size: float = 100.0,         # 最大跟单金额
        allow_dca: bool = False,              # 是否允许 DCA 加仓（默认关闭）
        data_file: str = "copy_trading_state.json",
        cold_start_snapshot_size: int = 50,   # 冷启动快照保存的最近交易数量
    ):
        """
        初始化跟单策略

        Args:
            target_user: 要追踪的目标用户地址
            copy_amount: 固定跟单金额（USDC），除非指定 copy_ratio
            copy_ratio: 跟单比例，例如 1.0 表示 100% 复制交易金额
            time_window: 时间窗口（秒），只跟此时间范围内的交易
            enable_partial_copy: 是否允许部分复制（大单拆分）
            max_copy_size: 最大跟单金额
            allow_dca: 是否允许 DCA 加仓模式（开启后会追加买入已持仓的市场）
            data_file: 状态文件路径（持久化已处理交易）
            cold_start_snapshot_size: 冷启动快照保存的最近交易数量
        """
        super().__init__("copy_trading")

        # 停止标志（用于支持 Ctrl+C 中断）
        self.running = True

        # 目标用户
        self.target_user = target_user or self.DEFAULT_TARGET_USER

        # 跟单参数
        self.copy_amount = copy_amount
        self.copy_ratio = copy_ratio
        self.time_window = time_window
        self.enable_partial_copy = enable_partial_copy
        self.max_copy_size = max_copy_size
        self.allow_dca = allow_dca

        # 冷启动快照配置
        self.cold_start_snapshot_size = cold_start_snapshot_size
        self.cold_start_snapshot_file = "cold_start_snapshot.json"

        # 持久化存储
        self.data_file = data_file
        self._load_state()

        # 市场信息缓存（condition_id -> market_info）
        self.market_cache = {}

        # API 请求配置
        self.api_timeout = 10
        self.max_retries = 3
        self.retry_delay = 1.0

        self.logger.info(f"CopyTradingStrategy initialized")
        self.logger.info(f"  Target user: {self.target_user[:10]}...{self.target_user[-6:]}")
        self.logger.info(f"  Copy amount: ${copy_amount}")
        self.logger.info(f"  Allow DCA: {allow_dca}")
        self.logger.info(f"  Time window: {time_window}s")
        self.logger.info(f"  State file: {data_file}")
        self.logger.info(f"  Cold start snapshot size: {cold_start_snapshot_size}")

        # 执行冷启动快照（如果不存在）
        self._ensure_cold_start_snapshot()

    def _load_state(self):
        """加载持久化的状态"""
        self.processed_trade_ids = set()
        self.last_trade_time = 0

        if os.path.exists(self.data_file):
            try:
                with open(self.data_file, 'r') as f:
                    data = json.load(f)
                    self.processed_trade_ids = set(data.get('trade_ids', []))
                    self.last_trade_time = data.get('last_trade_time', 0)
                    self.logger.info(f"Loaded state: {len(self.processed_trade_ids)} processed trades")
            except Exception as e:
                self.logger.warning(f"Failed to load state: {e}")

    def _save_state(self):
        """保存状态到文件"""
        try:
            data = {
                'trade_ids': list(self.processed_trade_ids),
                'last_trade_time': self.last_trade_time,
                'updated_at': datetime.now().isoformat()
            }
            with open(self.data_file, 'w') as f:
                json.dump(data, f, indent=2)
        except Exception as e:
            self.logger.error(f"Failed to save state: {e}")

    def _ensure_cold_start_snapshot(self):
        """
        确保冷启动快照存在
        如果快照文件不存在，则创建快照
        """
        if os.path.exists(self.cold_start_snapshot_file):
            self.logger.info(f"Cold start snapshot already exists: {self.cold_start_snapshot_file}")
            return

        self.logger.info(f"Creating cold start snapshot (size: {self.cold_start_snapshot_size})...")

        # 获取当前交易作为冷启动快照
        url = "https://data-api.polymarket.com/trades"
        params = {
            "user": self.target_user,
            "limit": self.cold_start_snapshot_size
        }

        data = self._api_request_with_retry(url, params)
        if data is None:
            self.logger.warning("Failed to create cold start snapshot (API error)")
            return

        # 提取交易数据
        if isinstance(data, dict) and 'data' in data:
            trades = data['data']
        elif isinstance(data, list):
            trades = data
        else:
            self.logger.warning("Failed to create cold start snapshot (unexpected format)")
            return

        # 保存快照
        self._save_cold_start_snapshot(trades)
        self.logger.info(f"Cold start snapshot created with {len(trades)} trades")

    def _save_cold_start_snapshot(self, trades: List[Dict]):
        """保存冷启动快照到文件"""
        try:
            snapshot_data = {
                'target_user': self.target_user,
                'trade_count': len(trades),
                'created_at': datetime.now().isoformat(),
                'trades': trades
            }
            with open(self.cold_start_snapshot_file, 'w') as f:
                json.dump(snapshot_data, f, indent=2)
            self.logger.info(f"Saved cold start snapshot to {self.cold_start_snapshot_file}")
        except Exception as e:
            self.logger.error(f"Failed to save cold start snapshot: {e}")

    def _get_cold_start_trade_ids(self) -> set:
        """获取冷启动快照中的交易ID集合"""
        if not os.path.exists(self.cold_start_snapshot_file):
            return set()

        try:
            with open(self.cold_start_snapshot_file, 'r') as f:
                data = json.load(f)
                trades = data.get('trades', [])
                trade_ids = set()
                for trade in trades:
                    trade_id = trade.get('transactionHash') or trade.get('id') or trade.get('orderId')
                    if trade_id:
                        trade_ids.add(trade_id)
                return trade_ids
        except Exception as e:
            self.logger.warning(f"Failed to load cold start snapshot: {e}")
            return set()

    def _is_cold_start_trade(self, trade_id: str) -> bool:
        """检查交易是否在冷启动快照中"""
        cold_start_ids = self._get_cold_start_trade_ids()
        if not cold_start_ids:
            return False
        return trade_id in cold_start_ids

    def _api_request_with_retry(
        self,
        url: str,
        params: Dict = None,
        method: str = 'GET',
        max_retries: int = None
    ) -> Optional[Any]:
        """带重试机制的 API 请求 - 改进版，使用更长超时"""
        max_retries = max_retries or self.max_retries

        for attempt in range(max_retries):
            # 每次重试前检查停止标志
            if not self.running:
                self.logger.info("Stopping, aborting API request")
                return None

            try:
                if method.upper() == 'GET':
                    response = requests.get(url, params=params, timeout=15)  # 使用更长超时
                else:
                    response = requests.post(url, json=params, timeout=15)

                response.raise_for_status()
                return response.json()

            except requests.exceptions.Timeout:
                self.logger.warning(f"API request timeout (attempt {attempt + 1}/{max_retries})")
                if attempt < max_retries - 1:
                    time.sleep(1.0)  # 等待1秒再重试
                else:
                    return None

            except requests.exceptions.RequestException as e:
                self.logger.warning(f"API request attempt {attempt + 1}/{max_retries} failed: {e}")
                if attempt < max_retries - 1:
                    time.sleep(1.0)  # 等待1秒再重试
                else:
                    self.logger.error(f"All retries exhausted for {url}")
                    return None

        return None

    def _fetch_target_trades(self) -> List[Dict[str, Any]]:
        """获取目标用户的最新交易"""
        url = "https://data-api.polymarket.com/trades"
        params = {
            "user": self.target_user,
            "limit": 50  # 获取更多交易以便筛选
        }

        self.logger.info(f"Fetching trades from {self._short_addr(self.target_user)}...")
        data = self._api_request_with_retry(url, params)

        if data is None:
            self.logger.warning("Failed to fetch trades (API error)")
            return []

        # 确保返回列表
        if isinstance(data, dict) and 'data' in data:
            trades = data['data']
        elif isinstance(data, list):
            trades = data
        else:
            self.logger.warning(f"Unexpected response format: {type(data)}")
            return []

        self.logger.info(f"Fetched {len(trades)} trades from API")
        return trades

    def _get_condition_id_from_trade(self, trade: Dict[str, Any]) -> Optional[str]:
        """从交易记录中提取 condition_id"""
        # 优先使用直接的 conditionId 字段
        condition_id = trade.get('conditionId') or trade.get('condition_id')
        if condition_id:
            return condition_id

        # 尝试从 market URL 或其他字段提取
        market_url = trade.get('marketUrl') or trade.get('market_url')
        if market_url:
            # 从 URL 中提取 condition_id
            parts = market_url.split('/')
            for part in parts:
                if len(part) == 66 or (part.startswith('0x') and len(part) == 66):
                    return part

        return None

    def _get_token_id_from_trade(self, trade: Dict[str, Any], markets: List[Dict] = None) -> Optional[str]:
        """
        从交易记录中提取有效的 token_id
        使用多种方法：
        1. 优先使用 Gamma API 通过 outcome 和 price 匹配
        2. 尝试验证 asset 字段是否有效
        """
        # 方法1: 通过 outcome 和 price 在 Gamma API 市场中查找
        if markets:
            token_id = self._find_token_by_market_info(trade, markets)
            if token_id:
                self.logger.debug(f"Found valid token via outcome/price match: {token_id[:20]}...")
                return token_id

        # 方法2: 直接使用 asset 字段并验证
        asset = trade.get('asset') or trade.get('clobTokenId') or trade.get('tokenId')
        if asset:
            if self._check_orderbook_valid(str(asset)):
                self.logger.debug(f"Found valid token via asset: {str(asset)[:20]}...")
                return str(asset)
            else:
                self.logger.debug(f"Asset token invalid: {str(asset)[:20]}...")

        return None

    def _check_orderbook_valid(self, token_id: str) -> bool:
        """
        检查 token_id 是否有有效的 orderbook
        返回 True 表示有效，False 表示无效
        快速超时模式，支持 Ctrl+C 中断
        """
        # 检查停止标志
        if not self.running:
            return False

        try:
            url = f"https://clob.polymarket.com/book"
            params = {"token_id": token_id}
            resp = requests.get(url, params=params, timeout=2)  # 快速超时
            if resp.status_code == 200:
                return True  # 有效，有订单簿
            else:
                return False  # 404 或其他错误都表示无效
        except requests.exceptions.Timeout:
            return False
        except Exception:
            return False

    def _get_trade_amount(self, trade: Dict[str, Any]) -> float:
        """提取交易金额（USDC）"""
        # 优先使用 size 字段
        size = trade.get('size') or trade.get('amount')
        if size:
            try:
                return float(size)
            except (ValueError, TypeError):
                pass

        # 尝试从 price 和 shares 计算
        price = trade.get('price') or trade.get('avgPrice')
        shares = trade.get('shares') or trade.get('quantity')

        if price and shares:
            try:
                return float(price) * float(shares)
            except (ValueError, TypeError):
                pass

        return 0.0

    def _get_market_info(self, condition_id: str) -> Optional[Dict[str, Any]]:
        """获取市场信息（带缓存）"""
        if not condition_id:
            return None

        # 检查缓存
        if condition_id in self.market_cache:
            return self.market_cache[condition_id]

        # 从 CLOB API 获取
        url = f"https://clob.polymarket.com/markets/{condition_id}"
        data = self._api_request_with_retry(url)

        if data:
            self.market_cache[condition_id] = data
            return data

        return None

    def _get_market_question(self, condition_id: str) -> str:
        """获取市场问题（用于日志）"""
        if not condition_id:
            return "Unknown Market"

        market_info = self._get_market_info(condition_id)
        if market_info:
            question = market_info.get('question') or market_info.get('title')
            if question:
                # 截断过长的标题
                if len(question) > 50:
                    question = question[:47] + "..."
                return question

        return condition_id[:12] + "..."

    def _is_market_settled(self, condition_id: str) -> bool:
        """
        检查市场是否已结算

        Returns:
            True if market is settled/closed, False otherwise
        """
        if not condition_id:
            return False

        market_info = self._get_market_info(condition_id)
        if not market_info:
            # 无法获取市场信息，尝试通过 orderbook 判断
            return False

        # 检查市场关闭状态
        is_closed = market_info.get('closed', False) or market_info.get('endDate', None)
        if is_closed:
            return True

        # 检查是否有结算价（代表已结算）
        resolution = market_info.get('resolution', None)
        if resolution and resolution != 'null':
            return True

        return False

    def _get_settlement_price(self, condition_id: str, token_id: str, outcome: str = None) -> Optional[float]:
        """
        获取市场的结算价

        Args:
            condition_id: 市场条件ID
            token_id: Token ID
            outcome: 预期的结果（Yes/No 或具体的 outcome 名称）

        Returns:
            结算价（0.0 或 1.0），如果市场未结算则返回 None
        """
        if not condition_id:
            return None

        market_info = self._get_market_info(condition_id)
        if not market_info:
            return None

        # 获取结算结果
        resolution = market_info.get('resolution', '')
        if not resolution or resolution == 'null':
            return None  # 市场未结算

        # 解析结算结果
        # resolution 可能是 "Yes", "No", 或者具体的 outcome 名称
        resolution_lower = resolution.lower()

        # 获取市场的 tokens
        tokens = market_info.get('tokens', [])
        if not tokens:
            # 尝试从 token_id 推断
            return 1.0 if resolution_lower in ['yes', 'true', '1'] else 0.0

        # 匹配 outcome 获取对应 token 的结算价
        for token in tokens:
            token_outcome = token.get('outcome', '').lower()
            token_id_in_market = token.get('token_id', '')

            # 如果 token_id 匹配，直接返回结算价
            if token_id_in_market == token_id:
                # 结算价应该是 0 或 1
                return 1.0 if resolution_lower == token_outcome.lower() else 0.0

            # 如果 outcome 名称匹配
            if token_outcome == resolution_lower or resolution_lower in token_outcome:
                return 1.0

        # 如果无法匹配，默认按 resolution 判断
        return 1.0 if resolution_lower in ['yes', 'true', '1', 'correct', 'won'] else 0.0

    def _check_orderbook_tradable(self, token_id: str) -> bool:
        """
        检查市场是否可交易（有有效的订单簿）

        Args:
            token_id: Token ID

        Returns:
            True if orderbook exists and has depth, False otherwise
        """
        try:
            url = f"https://clob.polymarket.com/book"
            params = {"token_id": token_id}
            resp = requests.get(url, params=params, timeout=5)
            if resp.status_code == 200:
                data = resp.json()
                bids = data.get('bids', [])
                asks = data.get('asks', [])
                # 如果有订单则可交易
                return len(bids) > 0 or len(asks) > 0
            return False
        except Exception:
            return False

    def _find_token_by_condition(self, condition_id: str, markets: List[Dict]) -> Optional[Dict]:
        """
        在市场列表中查找对应的 token 信息
        通过 outcome 和 price 匹配（这是最可靠的方法）
        """
        # 获取交易的 outcome 和 price
        # 由于我们没有直接传入这些信息，尝试从 trade 中获取
        return None

    def _find_token_by_market_info(self, trade: Dict[str, Any], markets: List[Dict]) -> Optional[str]:
        """
        通过 outcome 和 price 在 Gamma API 市场列表中查找有效的 token_id
        这是最可靠的匹配方法
        """
        if not markets:
            return None

        outcome = trade.get('outcome', '')
        trade_price = trade.get('price', 0)

        if not outcome or not trade_price:
            return None

        for market in markets:
            tokens = market.get('tokens', [])
            if not tokens:
                continue

            # 解析市场的 outcome 和 price
            # 注意：tokens 格式是 {"token_id": "...", "outcome": "Yes/No", "price": 0.5}
            for token in tokens:
                token_id = token.get('token_id')
                token_outcome = token.get('outcome', '')
                token_price = float(token.get('price', 0)) if token.get('price') else 0

                # 匹配 outcome 和价格（容差 0.01）
                if token_outcome.lower() == outcome.lower() and abs(token_price - trade_price) < 0.01:
                    # 验证 token_id 是否有效
                    if self._check_orderbook_valid(token_id):
                        return token_id

        return None

    def _calculate_copy_size(self, trade_size: float) -> float:
        """计算跟单金额"""
        if self.copy_ratio:
            # 按比例复制
            copy_size = trade_size * self.copy_ratio
        else:
            # 固定金额
            copy_size = self.copy_amount

        # 应用最大金额限制
        copy_size = min(copy_size, self.max_copy_size)

        # 确保不低于最小交易金额
        copy_size = max(copy_size, 1.0)

        return copy_size

    def generate_signals(
        self,
        markets: List[Dict[str, Any]],
        positions: List[Dict[str, Any]],
        balance: float,
    ) -> List[Signal]:
        """
        生成跟单信号

        逻辑：
        1. 获取目标用户的最新交易
        2. 过滤出时间窗口内的未处理交易
        3. BUY 信号：如果没有持仓，则买入
        4. SELL 信号：如果有持仓，则卖出
        """
        signals = []

        # 检查是否应该停止
        if not self.running:
            self.logger.info("Strategy stopping, returning empty signals")
            return signals

        # 1. 获取目标用户的交易
        trades = self._fetch_target_trades()
        if not trades:
            self.logger.debug("No trades found for target user")
            return signals

        # 检查停止标志
        if not self.running:
            return signals

        # 2. 建立当前持仓索引
        position_map = {p.get("token_id"): p for p in positions}

        # 3. 记录这次获取到的交易数量
        new_trades_count = 0

        for trade in trades:
            # 检查停止标志（每处理一个交易检查一次）
            if not self.running:
                self.logger.info("Strategy stopped during trade processing")
                break

            # 提取交易信息
            trade_id = trade.get('transactionHash') or trade.get('id') or trade.get('orderId')
            if not trade_id:
                continue

            # 检查是否已处理
            if trade_id in self.processed_trade_ids:
                continue

            # 冷启动保护：检查是否在冷启动快照中
            if self._is_cold_start_trade(trade_id):
                self.logger.info(f"  -> 跳过冷启动交易: {trade_id[:16]}...")
                continue

            # 获取交易时间
            raw_time = trade.get('timestamp') or trade.get('createdAt') or trade.get('time')
            if not raw_time:
                continue

            try:
                if isinstance(raw_time, str):
                    trade_ts = parser.parse(raw_time).timestamp()
                else:
                    trade_ts = float(raw_time)
            except Exception:
                continue

            # 检查时间窗口
            time_diff = time.time() - trade_ts
            if time_diff > self.time_window:
                # 标记旧交易为已处理，避免下次再检查
                self.processed_trade_ids.add(trade_id)
                continue

            new_trades_count += 1
            self.logger.info(f"  -> 检测到新交易（非冷启动）: {side} ${trade_size:.2f} | {question}")

            # 提取交易信息
            condition_id = self._get_condition_id_from_trade(trade)
            # 使用 Gamma API 获取的有效 markets 来匹配 token_id
            token_id = self._get_token_id_from_trade(trade, markets)

            # 如果找不到有效的 token_id，跳过这笔交易
            if not token_id:
                self.logger.warning(f"无法获取有效的 token_id，跳过交易 {trade_id[:16]}...")
                self.processed_trade_ids.add(trade_id)
                continue

            # 获取市场信息用于日志
            question = self._get_market_question(condition_id)

            # 检查市场是否已结算（通过市场信息）
            is_settled = self._is_market_settled(condition_id)
            if is_settled:
                self.logger.info(f"市场已结算，跳过交易 {trade_id[:16]}... | {question}")
                self.processed_trade_ids.add(trade_id)
                continue

            # 分析交易价格状态（检测结算交易）
            price_status = self._get_trade_price_status(trade)

            self.logger.info(f"New trade detected: {side} ${trade_size:.2f} | {question}")
            self.logger.debug(f"  Trade ID: {trade_id}")
            self.logger.debug(f"  Condition ID: {condition_id}")
            self.logger.debug(f"  Token ID: {token_id}")
            self.logger.debug(f"  Price Status: {price_status['description']}")

            # 提取交易的 outcome 用于后续结算价匹配
            trade_outcome = trade.get('outcome', '')

            # 4. 生成信号
            if side == "BUY":
                # 检测是否是结算交易（价格接近0或1）
                if price_status['type'] in ['SETTLEMENT_LOSS', 'SETTLEMENT_WIN']:
                    self.logger.info(f"  -> 检测到结算交易，价格={price_status['price']:.2f}，跳过")
                    self.processed_trade_ids.add(trade_id)
                    continue

                # 检查是否已有持仓
                if token_id and token_id not in position_map:
                    # 新建仓位
                    copy_size = self._calculate_copy_size(trade_size)

                    if balance >= copy_size or self._is_dry_run():
                        signals.append(Signal(
                            token_id=token_id,
                            side="BUY",
                            size=copy_size,
                            reason=f"跟单 {self._short_addr(self.target_user)}: [{question}] BUY ${trade_size:.2f} → 跟单 ${copy_size:.2f}"
                        ))
                        self.logger.info(f"  -> 生成 BUY 信号 (新建): ${copy_size:.2f}")
                    else:
                        self.logger.warning(f"  -> 余额不足 ${copy_size:.2f}，跳过")

                elif token_id in position_map:
                    # 已有持仓
                    if self.allow_dca:
                        # DCA 模式：允许加仓
                        position = position_map[token_id]
                        current_size = float(position.get('size', 0))
                        copy_size = self._calculate_copy_size(trade_size)

                        # 检查总仓位是否超过限制
                        total_size = current_size + copy_size
                        if total_size <= self.max_copy_size:
                            if balance >= copy_size or self._is_dry_run():
                                signals.append(Signal(
                                    token_id=token_id,
                                    side="BUY",
                                    size=copy_size,
                                    reason=f"跟单 {self._short_addr(self.target_user)}: [{question}] DCA 加仓 ${trade_size:.2f} → +${copy_size:.2f}"
                                ))
                                self.logger.info(f"  -> 生成 BUY 信号 (DCA加仓): ${copy_size:.2f} (当前: ${current_size:.2f}, 合计: ${total_size:.2f})")
                            else:
                                self.logger.warning(f"  -> 余额不足 ${copy_size:.2f}，跳过")
                        else:
                            self.logger.warning(f"  -> DCA 后仓位 ${total_size:.2f} 超过限制 ${self.max_copy_size:.2f}，跳过")
                    else:
                        self.logger.info(f"  -> 已有持仓，跳过 BUY (DCA模式未开启)")

            elif side == "SELL":
                # 冷启动保护：必须先检查是否持有该资产
                if not token_id:
                    self.logger.debug(f"  -> 跳过卖出：无法获取有效的 token_id")
                    self.processed_trade_ids.add(trade_id)
                    continue

                if token_id not in position_map:
                    # 冷启动阶段：目标用户卖出旧仓位，但我方并未持有
                    self.logger.info(f"  -> 跳过卖出：冷启动未持有该资产 (Token ID: {token_id[:20]}...)")
                    self.processed_trade_ids.add(trade_id)
                    continue

                # 正常执行卖出逻辑
                position = position_map[token_id]
                current_size = float(position.get('size', 0))

                if current_size > 0:
                    # 确定卖出价格
                    if price_status['type'] in ['SETTLEMENT_LOSS', 'SETTLEMENT_WIN']:
                        # 使用结算价
                        sell_price = price_status['price']
                        reason_suffix = f" (结算价: {sell_price:.2f})"
                    else:
                        # 正常卖出，使用市价单
                        sell_price = None
                        reason_suffix = ""

                    signals.append(Signal(
                        token_id=token_id,
                        side="SELL",
                        size=current_size,  # 卖出全部持仓
                        price=sell_price,  # 结算价或市价单
                        reason=f"跟单 {self._short_addr(self.target_user)}: [{question}] SELL → 卖出全部 ${current_size:.2f}{reason_suffix}"
                    ))
                    self.logger.info(f"  -> 生成 SELL 信号: ${current_size:.2f}{reason_suffix}")

            # 标记为已处理
            self.processed_trade_ids.add(trade_id)

        # 保存状态
        if new_trades_count > 0:
            self._save_state()
            self.logger.info(f"Processed {new_trades_count} new trades")

        return signals

    def _is_dry_run(self) -> bool:
        """检查是否在干跑模式"""
        # 通过日志级别判断
        return logger.isEnabledFor(logging.WARNING)

    def _close_settled_positions(
        self,
        positions: List[Dict[str, Any]],
    ) -> List[Signal]:
        """
        自动平仓已结算市场的持仓

        Args:
            positions: 当前持仓列表

        Returns:
            SELL 信号列表（用于已结算市场）
        """
        signals = []
        settled_count = 0

        for position in positions:
            token_id = position.get('token_id')
            if not token_id:
                continue

            # 跳过虚拟持仓的平仓（因为它们已经在虚拟系统中处理）
            if position.get('is_virtual', False):
                continue

            # 获取 position 的 condition_id（如果有）
            # 注意：这里需要通过 token_id 或其他方式获取 condition_id
            # 目前我们没有直接存储这个信息，需要通过市场信息来推断

            # 尝试获取市场信息
            market_info = self._get_market_info_by_token(token_id)
            if not market_info:
                continue

            condition_id = market_info.get('condition_id') or market_info.get('id')
            resolution = market_info.get('resolution', '')

            # 检查是否已结算
            if not resolution or resolution == 'null':
                continue

            # 市场已结算，生成 SELL 信号
            size = float(position.get('size', 0))
            if size <= 0:
                continue

            # 获取结算价
            settlement_price = self._get_settlement_price(condition_id, token_id)
            if settlement_price is None:
                # 无法获取结算价，使用 resolution 推断
                settlement_price = 1.0 if resolution.lower() in ['yes', 'true', '1', 'correct', 'won'] else 0.0

            question = market_info.get('question', market_info.get('title', token_id[:12] + '...'))

            # 生成 SELL 信号，使用结算价
            signals.append(Signal(
                token_id=token_id,
                side="SELL",
                size=size,
                price=settlement_price,  # 使用结算价
                reason=f"自动平仓: 市场已结算 [{resolution}] | {question}"
            ))

            settled_count += 1
            self.logger.info(f"  -> 自动平仓信号: {token_id[:20]}... @ ${settlement_price:.2f} (结算: {resolution})")

        if settled_count > 0:
            self.logger.info(f"生成了 {settled_count} 个自动平仓信号")

        return signals

    def _get_market_info_by_token(self, token_id: str) -> Optional[Dict[str, Any]]:
        """
        通过 token_id 获取市场信息（带缓存）

        Args:
            token_id: Token ID

        Returns:
            市场信息字典
        """
        if not token_id:
            return None

        # 检查缓存
        for condition_id, market_info in self.market_cache.items():
            tokens = market_info.get('tokens', [])
            for token in tokens:
                if token.get('token_id') == token_id:
                    return market_info

        # 从 CLOB API 获取
        try:
            url = f"https://clob.polymarket.com/markets/tokens/{token_id}"
            resp = requests.get(url, timeout=10)
            if resp.status_code == 200:
                data = resp.json()
                # 缓存市场信息
                condition_id = data.get('condition_id')
                if condition_id:
                    self.market_cache[condition_id] = data
                return data
        except Exception as e:
            self.logger.warning(f"Failed to fetch market info for token {token_id[:20]}...: {e}")

        return None

    def _check_trade_status(self, transaction_hash: str) -> Dict[str, Any]:
        """
        检查交易的确认状态（通过 Polymarket API）

        Args:
            transaction_hash: 交易哈希

        Returns:
            包含交易状态的字典
        """
        try:
            url = "https://data-api.polymarket.com/transactions"
            params = {"hash": transaction_hash}
            resp = requests.get(url, params=params, timeout=10)

            if resp.status_code == 200:
                data = resp.json()
                # 提取交易状态
                status = data.get('status', data.get('transactionStatus', ''))
                return {
                    'status': status,
                    'is_confirmed': status in ['CONFIRMED', 'MINED', 'SETTLED'],
                    'block_number': data.get('blockNumber'),
                    'gas_used': data.get('gasUsed'),
                }

            return {'status': 'UNKNOWN', 'is_confirmed': False}

        except Exception as e:
            self.logger.warning(f"Failed to check trade status for {transaction_hash[:16]}...: {e}")
            return {'status': 'UNKNOWN', 'is_confirmed': False}

    def _is_market_settled_by_trades(self, condition_id: str, token_id: str) -> bool:
        """
        通过检查目标用户的交易来判断市场是否已结算
        如果目标用户在该市场的最新交易价格接近 0 或 1，可能表示市场已结算

        Args:
            condition_id: 市场条件ID
            token_id: Token ID

        Returns:
            True 如果市场可能已结算
        """
        try:
            # 获取该市场的最新交易
            url = "https://data-api.polymarket.com/trades"
            params = {
                "user": self.target_user,
                "limit": 5
            }

            resp = requests.get(url, params=params, timeout=10)
            if resp.status_code != 200:
                return False

            data = resp.json()
            trades = data.get('data', []) if isinstance(data, dict) else data

            # 查找该市场的交易
            for trade in trades:
                trade_condition = trade.get('conditionId', trade.get('condition_id', ''))
                if trade_condition == condition_id:
                    price = float(trade.get('price', 0))
                    size = float(trade.get('size', 0))

                    # 如果价格接近 0 或 1，可能表示结算
                    if price <= 0.01 or price >= 0.99:
                        return True

                    # 检查交易是否已被确认（通过状态判断）
                    status = trade.get('status', '')
                    if status in ['CONFIRMED', 'MINED', 'SETTLED']:
                        return True

            return False

        except Exception as e:
            self.logger.warning(f"Failed to check market settlement via trades: {e}")
            return False

    def _get_trade_price_status(self, trade: Dict[str, Any]) -> Dict[str, Any]:
        """
        分析交易的 price 状态，判断是否是正常交易还是结算

        Args:
            trade: 交易数据字典

        Returns:
            包含价格状态的字典
        """
        price = float(trade.get('price', 0))
        size = float(trade.get('size', 0))

        # 根据价格判断交易类型
        if price <= 0.01:
            return {
                'type': 'SETTLEMENT_LOSS',
                'price': 0.0,
                'description': '结算价格（亏损）'
            }
        elif price >= 0.99:
            return {
                'type': 'SETTLEMENT_WIN',
                'price': 1.0,
                'description': '结算价格（盈利）'
            }
        elif 0.45 <= price <= 0.55:
            return {
                'type': 'NORMAL_MID',
                'price': price,
                'description': '正常中间价交易'
            }
        elif price < 0.3:
            return {
                'type': 'NORMAL_LOW',
                'price': price,
                'description': '正常低价交易'
            }
        elif price > 0.7:
            return {
                'type': 'NORMAL_HIGH',
                'price': price,
                'description': '正常高价交易'
            }
        else:
            return {
                'type': 'NORMAL',
                'price': price,
                'description': '正常交易'
            }

    def _short_addr(self, addr: str) -> str:
        """短地址显示"""
        if len(addr) <= 12:
            return addr
        return f"{addr[:6]}...{addr[-4:]}"

    def clear_processed_trades(self):
        """清空已处理交易记录（重新同步所有历史交易）"""
        count = len(self.processed_trade_ids)
        self.processed_trade_ids.clear()
        self._save_state()
        self.logger.info(f"Cleared {count} processed trades")

    def clear_cold_start_snapshot(self):
        """清除冷启动快照（重新创建快照）"""
        if os.path.exists(self.cold_start_snapshot_file):
            os.remove(self.cold_start_snapshot_file)
            self.logger.info(f"Cleared cold start snapshot: {self.cold_start_snapshot_file}")
        else:
            self.logger.info("No cold start snapshot to clear")

    def get_status(self) -> Dict[str, Any]:
        """获取策略状态"""
        # 获取冷启动快照中的交易数量
        cold_start_count = len(self._get_cold_start_trade_ids())
        return {
            "target_user": self.target_user,
            "copy_amount": self.copy_amount,
            "copy_ratio": self.copy_ratio,
            "allow_dca": self.allow_dca,
            "max_copy_size": self.max_copy_size,
            "time_window": self.time_window,
            "processed_trades": len(self.processed_trade_ids),
            "cold_start_trades": cold_start_count,
            "cached_markets": len(self.market_cache),
            "state_file": self.data_file,
            "cold_start_snapshot_file": self.cold_start_snapshot_file
        }


class ExampleMomentumStrategy(BaseStrategy):
    """
    动量策略（保持向后兼容）

    功能：
    - 价格快速上涨时买入
    - 达到盈利目标时卖出
    - 下跌时止损
    """

    def __init__(
        self,
        momentum_threshold: float = 0.1,    # 触发阈值（10%）
        target_profit: float = 0.15,         # 止盈目标（15%）
        max_position_per_market: float = 10.0,
    ):
        super().__init__("momentum")

        # 策略参数
        self.momentum_threshold = momentum_threshold
        self.target_profit = target_profit
        self.max_position_per_market = max_position_per_market

        # 缓存
        self.price_cache = {}  # token_id -> (price, timestamp)

    def generate_signals(
        self,
        markets: List[Dict[str, Any]],
        positions: List[Dict[str, Any]],
        balance: float,
    ) -> List[Signal]:
        """Generate momentum-based signals"""
        signals = []

        # 建立持仓索引
        position_map = {p.get("token_id"): p for p in positions}

        for market in markets:
            # 跳过关闭的市场
            if market.get("closed", False):
                continue

            tokens = market.get("tokens", [])
            if not tokens:
                continue

            token = tokens[0]
            token_id = token.get("token_id")
            current_price = float(token.get("price", 0))

            if not token_id or current_price <= 0:
                continue

            # 获取历史价格
            last_price, last_time = self.price_cache.get(token_id, (current_price, time.time()))

            # 计算价格变动
            price_change = (current_price - last_price) / last_price if last_price > 0 else 0

            # 更新缓存
            self.price_cache[token_id] = (current_price, time.time())

            # 检查持仓
            if token_id in position_map:
                position = position_map[token_id]
                entry_price = float(position.get("average_price", 0))
                size = float(position.get("size", 0))

                # 计算未实现盈亏
                unrealized_pnl = (current_price - entry_price) / entry_price if entry_price > 0 else 0

                # 止盈
                if unrealized_pnl >= self.target_profit:
                    signals.append(Signal(
                        token_id=token_id,
                        side="SELL",
                        size=size,
                        reason=f"止盈: {unrealized_pnl:.1%} >= {self.target_profit:.1%}"
                    ))
                    del self.price_cache[token_id]  # 清缓存

                # 止损
                elif unrealized_pnl <= -self.momentum_threshold:
                    signals.append(Signal(
                        token_id=token_id,
                        side="SELL",
                        size=size,
                        reason=f"止损: {unrealized_pnl:.1%} <= -{self.momentum_threshold:.1%}"
                    ))
                    del self.price_cache[token_id]

            else:
                # 没有持仓，检查是否应该买入
                if price_change >= self.momentum_threshold and balance >= 10:
                    size = min(self.max_position_per_market, balance * 0.1)
                    signals.append(Signal(
                        token_id=token_id,
                        side="BUY",
                        size=size,
                        reason=f"动量买入: 价格变动 {price_change:.1%} >= {self.momentum_threshold:.1%}"
                    ))

        return signals


class ExampleArbitrageStrategy(BaseStrategy):
    """
    Example strategy: Simple arbitrage detection

    This strategy looks for related markets where probabilities don't add up correctly
    """

    def __init__(self, min_edge: float = 0.05):
        """
        Initialize arbitrage strategy

        Args:
            min_edge: Minimum edge to trigger trade (e.g., 0.05 = 5%)
        """
        super().__init__("arbitrage")
        self.min_edge = min_edge

    def generate_signals(
        self,
        markets: List[Dict[str, Any]],
        positions: List[Dict[str, Any]],
        balance: float,
    ) -> List[Signal]:
        """Generate signals based on arbitrage opportunities"""
        signals = []

        # Find related markets (same question, different outcomes)
        # This is a simplified example - real implementation would need more sophisticated matching
        market_groups = self._group_related_markets(markets)

        for group in market_groups:
            # Check if probabilities sum to more than 1 (arbitrage opportunity)
            total_prob = sum(float(m.get("tokens", [{}])[0].get("price", 0)) for m in group)

            if total_prob > 1.0 + self.min_edge:
                # Arbitrage opportunity - sell all outcomes
                for market in group:
                    token = market.get("tokens", [{}])[0]
                    token_id = token.get("token_id")
                    price = float(token.get("price", 0))

                    if token_id and price > 0.5:  # Only sell overpriced outcomes
                        size = min(50.0, balance * 0.1)  # Small position
                        signals.append(
                            Signal(
                                token_id=token_id,
                                side="SELL",
                                size=size,
                                reason=f"Arbitrage: total prob {total_prob:.2f}",
                            )
                        )

        return signals

    def _group_related_markets(self, markets: List[Dict[str, Any]]) -> List[List[Dict[str, Any]]]:
        """Group related markets - simplified implementation"""
        # In a real implementation, you'd group by question or event
        # For now, return empty list (no grouping)
        return []
